<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Tucano: Using the Effect and Shader Classes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="tucano.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tucano
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">A library for rapid prototyping with modern OpenGL and GLSL</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('effect_tutorial.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Using the Effect and Shader Classes </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The <a class="el" href="classTucano_1_1Effect.html">Effect</a> and <a class="el" href="classTucano_1_1Shader.html">Shader</a> Classes hold the core of the OpenGL/GLSL applications. A typical application has a Class (inheriting from <a class="el" href="classTucano_1_1Effect.html">Effect</a>) that contains <a class="el" href="classTucano_1_1Shader.html">Shader</a> objects. Many <a class="el" href="namespaceEffects.html">Effects</a> are multipass and contain many shaders.</p>
<p>It is possible to build an application without using the Effect Class at all, however there a few advantages in using the Effect:</p>
<ul>
<li>keeps all shaders belonging to the same effect encapsulated</li>
<li>keeps all variables for the effect encapsulated</li>
<li>keeps your application API simple</li>
<li>enables reloading all the effect's shaders with a single command</li>
<li>enhances portability, to use the same effect in another application, only need to include one header</li>
</ul>
<h1>A simple example effect</h1>
<p>Let's look at a simple Effect from <a class="el" href="namespaceTucano.html">Tucano</a>'s Collection, the <a class="el" href="classEffects_1_1NormalMap.html">NormalMap</a>. This effect renders a mesh using normals directions as color (normal map). We only need one Shader to create this effect.</p>
<p>First we create our class:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#include &quot;effect.hpp&quot;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;class NormalMap : public Tucano::Effect {</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;...</div>
</div><!-- fragment --><p>This class contains a single <a class="el" href="classTucano_1_1Effect.html">Shader</a>:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Tucano::Shader* normalmap_shader;</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>It's probably a good idea to initialize <b>normalmap_shader = 0</b> in your class constructor. If you use the effect loadShader method (explained below) the destructor will take care of deleting your shaders. </p>
</blockquote>
<p>We need to overload the initialization method to load the shader. The <code>loadShader</code> method will look in the set shader directory for files beginning with "normalmap" and shader extensions, in this case it will find two (.vert and .frag). The method also initializes the shaders and keeps references to them for reloading and deleting.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;virtual void initialize ()</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;{</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    normalmap_shader = loadShader(&quot;normalmap&quot;);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;}</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>Note that the above method assumes that the shader files (.vert, .frag, etc...) are in the "/shaders" directory relative to your executing directory. You may need to change this directory before calling the initialization using the <b>setShadersDir</b> method. </p>
</blockquote>
<p>Now, all we need is the core of the NormalMap application. We can implement it as a method that receives a <a class="el" href="classTucano_1_1Mesh.html">Mesh</a> and a camera <a class="el" href="classTucano_1_1Trackball.html">Trackball</a>, and renders the Mesh using the normal directions as colors:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;virtual void render (Tucano::Mesh* mesh, Tucano::Trackball* cameraTrackball)</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;{</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    Eigen::Vector4f viewport = cameraTrackball-&gt;getViewport();</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    glViewport(viewport[0], viewport[1], viewport[2], viewport[3]);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    // enables the shader</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    normalmap_shader-&gt;bind();</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    // passes the transformation matrices to the shader as uniforms</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    normalmap_shader-&gt;setUniform(&quot;projectionMatrix&quot;, cameraTrackball-&gt;getProjectionMatrix());</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    normalmap_shader-&gt;setUniform(&quot;modelMatrix&quot;, mesh-&gt;getModelMatrix());</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    normalmap_shader-&gt;setUniform(&quot;viewMatrix&quot;, cameraTrackball-&gt;getViewMatrix());</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    // links the Mesh attributes with the Shader vertex attributes (in this case gl_Position and gl_Normal)</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    mesh-&gt;setAttributeLocation(phong_shader);</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    mesh-&gt;render();</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    phong_shader-&gt;unbind();</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;}</div>
</div><!-- fragment --><p>And that's it. In the application's draw routine, we clear the screen and call the render method above. To see a visual representation of the trackball just render it! Just make sure that depth test is enabled. Here is a sample code for a typical draw method (you can find a similar method in the GLWidget Class of the phongViewer sample):</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;glClearColor(1.0, 1.0, 1.0, 0.0);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;normalmap_shader-&gt;render(mesh, camera_trackball);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;camera_trackball-&gt;render();</div>
</div><!-- fragment --><p>Here are the <em>vertex</em> and <em>fragment</em> shader codes for the files "normalmap.vert" and "normalmap.frag" (they are all included in the <code>effects/shaders</code> directory):</p>
<h3>normalmap.vert</h3>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#version 430</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;in vec4 in_Position;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;in vec3 in_Normal;    </div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;out vec3 normal;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;uniform mat4 modelMatrix;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;uniform mat4 viewMatrix;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;uniform mat4 projectionMatrix;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;void main(void)</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;{</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    normal = in_Normal;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    gl_Position = projectionMatrix * viewMatrix * modelMatrix * in_Position;    </div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;}</div>
</div><!-- fragment --><h3>normalmap.frag</h3>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#version 430</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;in vec3 normal;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;out vec4 out_Color;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;void main(void)</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;{</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    out_Color = vec4(abs(normal), 1.0);</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div>
</div><!-- fragment --><h1>A more complex example</h1>
<p>Let's say we want to create an effect called BlurredNormals. Its only an illustrative example. This effect uses the normalmap above and then blurs the final resulting image. It's a two pass method: first pass stores the normalmap result in an FBO; second pass blurs the resulting image from the first pass. If you are not familiar with FBOs, check out the <a class="el" href="framebuffer_tutorial.html">Framebuffer Tutorial</a>.</p>
<p>We now need two Shaders plus a Quad Mesh and an FBO for the screen space blur:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Tucano::Shader* normalmap_shader;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Tucano::Shader* blur_shader;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;Tucano::Mesh* quad;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;Tucano::Framebuffer *fbo;</div>
</div><!-- fragment --><p>The initialization method is completed as follows:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;virtual void initialize ()</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;{</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    normalmap_shader = loadShader(&quot;normalmap&quot;);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    blur_shader = loadShader(&quot;meanfilter&quot;);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    quad = new Tucano::Mesh();</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    quad-&gt;createQuad();</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    fbo = new Tucano::Framebuffer(w, h, 1);</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>Note that you need to pass the size of your viewport to initialize the FBO, we assume we know this and its (w,h). The last parameter of the FBO says that we only need one texture attachment. It's usually a good idea to initialize and re-initialize the FBO every time your window is resized (checkout the <a class="el" href="classTucano_1_1QtTrackballWidget.html">QtTrackballWidget</a> for an example). </p>
</blockquote>
<p>We show another way to set the FBO size below, after this example.</p>
<p>The render method now needs two passes, one to store the result in a FBO, and the second to blur the image:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;virtual void render (Tucano::Mesh* mesh, Tucano::Trackball* cameraTrackball)</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;{</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    // clears the FBO and sets the FBO first (and only) attachment as output</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    fbo-&gt;clearAttachments();</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    fbo-&gt;bindRenderBuffer(0);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    // *** this part of the code is identical to the first example ***</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    Eigen::Vector4f viewport = cameraTrackball-&gt;getViewport();</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    glViewport(viewport[0], viewport[1], viewport[2], viewport[3]);</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    // enables the shader</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    normalmap_shader-&gt;bind();</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    // passes the transformation matrices to the shader as uniforms</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    normalmap_shader-&gt;setUniform(&quot;projectionMatrix&quot;, cameraTrackball-&gt;getProjectionMatrix());</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    normalmap_shader-&gt;setUniform(&quot;modelMatrix&quot;, mesh-&gt;getModelMatrix());</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    normalmap_shader-&gt;setUniform(&quot;viewMatrix&quot;, cameraTrackball-&gt;getViewMatrix());</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    // links the Mesh attributes with the Shader vertex attributes (in this case gl_Position and gl_Normal)</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    mesh-&gt;setAttributeLocation(phong_shader);</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    mesh-&gt;render();</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    phong_shader-&gt;unbind();</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    // *** unbind the buffer as output buffer, and applies the blur filter ****</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    fbo-&gt;unbind(); // automatically returns the draw buffer to GL_BACK</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    blur_shader-&gt;bind();</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    // makes the FBO attachment read available from the shader</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    blur_shader-&gt;setUniform(&quot;imageTexture&quot;, fbo-&gt;bindAttachment(0));</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    // sets the blur kernel (higher == more</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    blur_shader-&gt;setUniform(&quot;kernelsize&quot;, 5);</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    quad-&gt;render();</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    blur_shader-&gt;unbind();</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    fbo-&gt;unbindAttachments();</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;}</div>
</div><!-- fragment --><p>And that is all!! The blur shaders files (meanfilter.vert and meanfilter.frag) are in the <em>effects/shaders</em> directory of the <a class="el" href="namespaceTucano.html">Tucano</a> Lib.</p>
<h2>Alternative to setting the FBO size during the initialization.</h2>
<p>Create an empty FBO in the initialize method:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;fbo = new Tucano::Framebuffer();</div>
</div><!-- fragment --><p>During the render method check if the FBO size is the same as the Viewport size, otherwise re-create the FBO (it will be initialized with zero)</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Eigen::Vector4f viewport = cameraTrackball-&gt;getViewport();</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;if (fbo-&gt;getWidth() != (viewport[2]-viewport[1]) || fbo-&gt;getHeight() != (viewport[3]-viewport[1]))</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;{</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    fbo-&gt;create(viewport[2]-viewport[1], viewport[3]-viewport[1], 1);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>Note that usually the first two elements of the viewport vector are zero (ex. [0, 0, w, h]). However, we have left it with as four elements for completeness.</p>
</blockquote>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Feb 21 2015 22:23:40 for Tucano by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
